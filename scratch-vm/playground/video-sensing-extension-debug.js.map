{"version":3,"file":"video-sensing-extension-debug.js","sources":["webpack://VirtualMachine/webpack/bootstrap","webpack://VirtualMachine/(webpack)/buildin/global.js","webpack://VirtualMachine/./src/extensions/scratch3_video_sensing/debug.js","webpack://VirtualMachine/./src/extensions/scratch3_video_sensing/library.js","webpack://VirtualMachine/./src/extensions/scratch3_video_sensing/math.js","webpack://VirtualMachine/./src/extensions/scratch3_video_sensing/view.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/extensions/scratch3_video_sensing/debug.js-exposed\");\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","/**\n * A debug \"index\" module exporting VideoMotion and VideoMotionView to debug\n * VideoMotion directly.\n * @file debug.js\n */\n\nconst VideoMotion = require('./library');\nconst VideoMotionView = require('./view');\n\nmodule.exports = {\n    VideoMotion,\n    VideoMotionView\n};\n","/**\n * @file library.js\n *\n * Tony Hwang and John Maloney, January 2011\n * Michael \"Z\" Goddard, March 2018\n *\n * Video motion sensing primitives.\n */\n\nconst {motionVector, scratchAtan2} = require('./math');\n\n/**\n * The width of the intended resolution to analyze for motion.\n * @type {number}\n */\nconst WIDTH = 480;\n\n/**\n * The height of the intended resolution to analyze for motion.\n * @type {number}\n */\nconst HEIGHT = 360;\n\n/**\n * A constant value to scale the magnitude of the x and y components called u\n * and v. This creates the motionAmount value.\n *\n * Old note: chosen empirically to give a range of roughly 0-100\n *\n * @type {number}\n */\nconst AMOUNT_SCALE = 100;\n\n/**\n * A constant value to scale the magnitude of the x and y components called u\n * and v in the local motion derivative. This creates the motionAmount value on\n * a target's motion state.\n *\n * Old note: note 2e-4 * activePixelNum is an experimentally tuned threshold\n * for my logitech Pro 9000 webcam - TTH\n *\n * @type {number}\n */\nconst LOCAL_AMOUNT_SCALE = AMOUNT_SCALE * 2e-4;\n\n/**\n * The motion amount must be higher than the THRESHOLD to calculate a new\n * direction value.\n * @type {number}\n */\nconst THRESHOLD = 10;\n\n/**\n * The size of the radius of the window of summarized values when considering\n * the motion inside the full resolution of the sample.\n * @type {number}\n */\nconst WINSIZE = 8;\n\n/**\n * A ceiling for the motionAmount stored to a local target's motion state. The\n * motionAmount is not allowed to be larger than LOCAL_MAX_AMOUNT.\n * @type {number}\n */\nconst LOCAL_MAX_AMOUNT = 100;\n\n/**\n * The motion amount for a target's local motion must be higher than the\n * LOCAL_THRESHOLD to calculate a new direction value.\n * @type {number}\n */\nconst LOCAL_THRESHOLD = THRESHOLD / 3;\n\n/**\n * Store the necessary image pixel data to compares frames of a video and\n * detect an amount and direction of motion in the full sample or in a\n * specified area.\n * @constructor\n */\nclass VideoMotion {\n    constructor () {\n        /**\n         * The number of frames that have been added from a source.\n         * @type {number}\n         */\n        this.frameNumber = 0;\n\n        /**\n         * The frameNumber last analyzed.\n         * @type {number}\n         */\n        this.lastAnalyzedFrame = 0;\n\n        /**\n         * The amount of motion detected in the current frame.\n         * @type {number}\n         */\n        this.motionAmount = 0;\n\n        /**\n         * The direction the motion detected in the frame is general moving in.\n         * @type {number}\n         */\n        this.motionDirection = 0;\n\n        /**\n         * A copy of the current frame's pixel values. A index of the array is\n         * represented in RGBA. The lowest byte is red. The next is green. The\n         * next is blue. And the last is the alpha value of that pixel.\n         * @type {Uint32Array}\n         */\n        this.curr = null;\n\n        /**\n         * A copy of the last frame's pixel values.\n         * @type {Uint32Array}\n         */\n        this.prev = null;\n\n        /**\n         * A buffer for holding one component of a pixel's full value twice.\n         * One for the current value. And one for the last value.\n         * @type {number}\n         */\n        this._arrays = new ArrayBuffer(WIDTH * HEIGHT * 2 * 1);\n\n        /**\n         * A clamped uint8 view of _arrays. One component of each index of the\n         * curr member is copied into this array.\n         * @type {number}\n         */\n        this._curr = new Uint8ClampedArray(this._arrays, WIDTH * HEIGHT * 0 * 1, WIDTH * HEIGHT);\n\n        /**\n         * A clamped uint8 view of _arrays. One component of each index of the\n         * prev member is copied into this array.\n         * @type {number}\n         */\n        this._prev = new Uint8ClampedArray(this._arrays, WIDTH * HEIGHT * 1 * 1, WIDTH * HEIGHT);\n    }\n\n    /**\n     * Reset internal state so future frame analysis does not consider values\n     * from before this method was called.\n     */\n    reset () {\n        this.frameNumber = 0;\n        this.lastAnalyzedFrame = 0;\n        this.motionAmount = this.motionDirection = 0;\n        this.prev = this.curr = null;\n    }\n\n    /**\n     * Add a frame to be next analyzed. The passed array represent a pixel with\n     * each index in the RGBA format.\n     * @param {Uint32Array} source - a source frame of pixels to copy\n     */\n    addFrame (source) {\n        this.frameNumber++;\n\n        // Swap curr to prev.\n        this.prev = this.curr;\n        // Create a clone of the array so any modifications made to the source\n        // array do not affect the work done in here.\n        this.curr = new Uint32Array(source.buffer.slice(0));\n\n        // Swap _prev and _curr. Copy one of the color components of the new\n        // array into _curr overwriting what was the old _prev data.\n        const _tmp = this._prev;\n        this._prev = this._curr;\n        this._curr = _tmp;\n        for (let i = 0; i < this.curr.length; i++) {\n            this._curr[i] = this.curr[i] & 0xff;\n        }\n    }\n\n    /**\n     * Analyze the current frame against the previous frame determining the\n     * amount of motion and direction of the motion.\n     */\n    analyzeFrame () {\n        if (!this.curr || !this.prev) {\n            this.motionAmount = this.motionDirection = -1;\n            // Don't have two frames to analyze yet\n            return;\n        }\n\n        // Return early if new data has not been received.\n        if (this.lastAnalyzedFrame === this.frameNumber) {\n            return;\n        }\n        this.lastAnalyzedFrame = this.frameNumber;\n\n        const {\n            _curr: curr,\n            _prev: prev\n        } = this;\n\n        const winStep = (WINSIZE * 2) + 1;\n        const wmax = WIDTH - WINSIZE - 1;\n        const hmax = HEIGHT - WINSIZE - 1;\n\n        // Accumulate 2d motion vectors from groups of pixels and average it\n        // later.\n        let uu = 0;\n        let vv = 0;\n        let n = 0;\n\n        // Iterate over groups of cells building up the components to determine\n        // a motion vector for each cell instead of the whole frame to avoid\n        // integer overflows.\n        for (let i = WINSIZE + 1; i < hmax; i += winStep) {\n            for (let j = WINSIZE + 1; j < wmax; j += winStep) {\n                let A2 = 0;\n                let A1B2 = 0;\n                let B1 = 0;\n                let C1 = 0;\n                let C2 = 0;\n\n                // This is a performance critical math region.\n                let address = ((i - WINSIZE) * WIDTH) + j - WINSIZE;\n                let nextAddress = address + winStep;\n                const maxAddress = ((i + WINSIZE) * WIDTH) + j + WINSIZE;\n                for (; address <= maxAddress; address += WIDTH - winStep, nextAddress += WIDTH) {\n                    for (; address <= nextAddress; address += 1) {\n                        // The difference in color between the last frame and\n                        // the current frame.\n                        const gradT = ((prev[address]) - (curr[address]));\n                        // The difference between the pixel to the left and the\n                        // pixel to the right.\n                        const gradX = ((curr[address - 1]) - (curr[address + 1]));\n                        // The difference between the pixel above and the pixel\n                        // below.\n                        const gradY = ((curr[address - WIDTH]) - (curr[address + WIDTH]));\n\n                        // Add the combined values of this pixel to previously\n                        // considered pixels.\n                        A2 += gradX * gradX;\n                        A1B2 += gradX * gradY;\n                        B1 += gradY * gradY;\n                        C2 += gradX * gradT;\n                        C1 += gradY * gradT;\n                    }\n                }\n\n                // Use the accumalated values from the for loop to determine a\n                // motion direction.\n                const {u, v} = motionVector(A2, A1B2, B1, C2, C1);\n\n                // If u and v are within negative winStep to positive winStep,\n                // add them to a sum that will later be averaged.\n                if (-winStep < u && u < winStep && -winStep < v && v < winStep) {\n                    uu += u;\n                    vv += v;\n                    n++;\n                }\n            }\n        }\n\n        // Average the summed vector values of all of the motion groups.\n        uu /= n;\n        vv /= n;\n\n        // Scale the magnitude of the averaged UV vector.\n        this.motionAmount = Math.round(AMOUNT_SCALE * Math.hypot(uu, vv));\n        if (this.motionAmount > THRESHOLD) {\n            // Scratch direction\n            this.motionDirection = scratchAtan2(vv, uu);\n        }\n    }\n\n    /**\n     * Build motion amount and direction values based on stored current and\n     * previous frame that overlaps a given drawable.\n     * @param {Drawable} drawable - touchable and bounded drawable to build motion for\n     * @param {MotionState} state - state to store built values to\n     */\n    getLocalMotion (drawable, state) {\n        if (!this.curr || !this.prev) {\n            state.motionAmount = state.motionDirection = -1;\n            // Don't have two frames to analyze yet\n            return;\n        }\n\n        // Skip if the current frame has already been considered for this state.\n        if (state.motionFrameNumber !== this.frameNumber) {\n            const {\n                _prev: prev,\n                _curr: curr\n            } = this;\n\n            // The public APIs for Renderer#isTouching manage keeping the matrix and\n            // silhouette up-to-date, which is needed for drawable#isTouching to work (used below)\n            drawable.updateMatrix();\n            if (drawable.skin) drawable.skin.updateSilhouette();\n\n            // Restrict the region the amount and direction are built from to\n            // the area of the current frame overlapped by the given drawable's\n            // bounding box.\n            const boundingRect = drawable.getFastBounds();\n            // Transform the bounding box from scratch space to a space from 0,\n            // 0 to WIDTH, HEIGHT.\n            const xmin = Math.max(Math.floor(boundingRect.left + (WIDTH / 2)), 1);\n            const xmax = Math.min(Math.floor(boundingRect.right + (WIDTH / 2)), WIDTH - 1);\n            const ymin = Math.max(Math.floor((HEIGHT / 2) - boundingRect.top), 1);\n            const ymax = Math.min(Math.floor((HEIGHT / 2) - boundingRect.bottom), HEIGHT - 1);\n\n            let A2 = 0;\n            let A1B2 = 0;\n            let B1 = 0;\n            let C1 = 0;\n            let C2 = 0;\n            let scaleFactor = 0;\n\n            const position = [0, 0, 0];\n\n            // This is a performance critical math region.\n            for (let i = ymin; i < ymax; i++) {\n                for (let j = xmin; j < xmax; j++) {\n                    // i and j are in a coordinate planning ranging from 0 to\n                    // HEIGHT and 0 to WIDTH. Transform that into Scratch's\n                    // range of HEIGHT / 2 to -HEIGHT / 2 and -WIDTH / 2 to\n                    // WIDTH / 2;\n                    position[0] = j - (WIDTH / 2);\n                    position[1] = (HEIGHT / 2) - i;\n                    // Consider only pixels in the drawable that can touch the\n                    // edge or other drawables. Empty space in the current skin\n                    // is skipped.\n                    if (drawable.isTouching(position)) {\n                        const address = (i * WIDTH) + j;\n                        // The difference in color between the last frame and\n                        // the current frame.\n                        const gradT = ((prev[address]) - (curr[address]));\n                        // The difference between the pixel to the left and the\n                        // pixel to the right.\n                        const gradX = ((curr[address - 1]) - (curr[address + 1]));\n                        // The difference between the pixel above and the pixel\n                        // below.\n                        const gradY = ((curr[address - WIDTH]) - (curr[address + WIDTH]));\n\n                        // Add the combined values of this pixel to previously\n                        // considered pixels.\n                        A2 += gradX * gradX;\n                        A1B2 += gradX * gradY;\n                        B1 += gradY * gradY;\n                        C2 += gradX * gradT;\n                        C1 += gradY * gradT;\n                        scaleFactor++;\n                    }\n                }\n            }\n\n            // Use the accumalated values from the for loop to determine a\n            // motion direction.\n            let {u, v} = motionVector(A2, A1B2, B1, C2, C1);\n\n            let activePixelNum = 0;\n            if (scaleFactor) {\n                // Store the area of the sprite in pixels\n                activePixelNum = scaleFactor;\n\n                scaleFactor /= (2 * WINSIZE * 2 * WINSIZE);\n                u = u / scaleFactor;\n                v = v / scaleFactor;\n            }\n\n            // Scale the magnitude of the averaged UV vector and the number of\n            // overlapping drawable pixels.\n            state.motionAmount = Math.round(LOCAL_AMOUNT_SCALE * activePixelNum * Math.hypot(u, v));\n            if (state.motionAmount > LOCAL_MAX_AMOUNT) {\n                // Clip all magnitudes greater than 100.\n                state.motionAmount = LOCAL_MAX_AMOUNT;\n            }\n            if (state.motionAmount > LOCAL_THRESHOLD) {\n                // Scratch direction.\n                state.motionDirection = scratchAtan2(v, u);\n            }\n\n            // Skip future calls on this state until a new frame is added.\n            state.motionFrameNumber = this.frameNumber;\n        }\n    }\n}\n\nmodule.exports = VideoMotion;\n","/**\n * A constant value helping to transform a value in radians to degrees.\n * @type {number}\n */\nconst TO_DEGREE = 180 / Math.PI;\n\n/**\n * A object reused to save on memory allocation returning u and v vector from\n * motionVector.\n * @type {UV}\n */\nconst _motionVectorOut = {u: 0, v: 0};\n\n/**\n * Determine a motion vector combinations of the color component difference on\n * the x axis, y axis, and temporal axis.\n * @param {number} A2 - a sum of x axis squared\n * @param {number} A1B2 - a sum of x axis times y axis\n * @param {number} B1 - a sum of y axis squared\n * @param {number} C2 - a sum of x axis times temporal axis\n * @param {number} C1 - a sum of y axis times temporal axis\n * @param {UV} out - optional object to store return UV info in\n * @returns {UV} a uv vector representing the motion for the given input\n */\nconst motionVector = function (A2, A1B2, B1, C2, C1, out = _motionVectorOut) {\n    // Compare sums of X * Y and sums of X squared and Y squared.\n    const delta = ((A1B2 * A1B2) - (A2 * B1));\n    if (delta) {\n        // System is not singular - solving by Kramer method.\n        const deltaX = -((C1 * A1B2) - (C2 * B1));\n        const deltaY = -((A1B2 * C2) - (A2 * C1));\n        const Idelta = 8 / delta;\n        out.u = deltaX * Idelta;\n        out.v = deltaY * Idelta;\n    } else {\n        // Singular system - find optical flow in gradient direction.\n        const Norm = ((A1B2 + A2) * (A1B2 + A2)) + ((B1 + A1B2) * (B1 + A1B2));\n        if (Norm) {\n            const IGradNorm = 8 / Norm;\n            const temp = -(C1 + C2) * IGradNorm;\n            out.u = (A1B2 + A2) * temp;\n            out.v = (B1 + A1B2) * temp;\n        } else {\n            out.u = 0;\n            out.v = 0;\n        }\n    }\n    return out;\n};\n\n/**\n * Translate an angle in degrees with the range -180 to 180 rotated to\n * Scratch's reference angle.\n * @param {number} degrees - angle in range -180 to 180\n * @returns {number} angle from Scratch's reference angle\n */\nconst scratchDegrees = function (degrees) {\n    return ((degrees + 270) % 360) - 180;\n};\n\n/**\n * Get the angle of the y and x component of a 2d vector in degrees in\n * Scratch's coordinate plane.\n * @param {number} y - the y component of a 2d vector\n * @param {number} x - the x component of a 2d vector\n * @returns {number} angle in degrees in Scratch's coordinate plane\n */\nconst scratchAtan2 = function (y, x) {\n    return scratchDegrees(Math.atan2(y, x) * TO_DEGREE);\n};\n\nmodule.exports = {\n    motionVector,\n    scratchDegrees,\n    scratchAtan2\n};\n","const {motionVector} = require('./math');\n\nconst WIDTH = 480;\nconst HEIGHT = 360;\nconst WINSIZE = 8;\nconst AMOUNT_SCALE = 100;\nconst THRESHOLD = 10;\n\n/**\n * Modes of debug output that can be rendered.\n * @type {object}\n */\nconst OUTPUT = {\n    /**\n     * Render the original input.\n     * @type {number}\n     */\n    INPUT: -1,\n\n    /**\n     * Render the difference of neighboring pixels for each pixel. The\n     * horizontal difference, or x value, renders in the red output component.\n     * The vertical difference, or y value, renders in the green output\n     * component. Pixels with equal neighbors with a kind of lime green or\n     * #008080 in a RGB hex value. Colors with more red have a lower value to\n     * the right than the value to the left. Colors with less red have a higher\n     * value to the right than the value to the left. Similarly colors with\n     * more green have lower values below than above and colors with less green\n     * have higher values below than above.\n     * @type {number}\n     */\n    XY: 0,\n\n    /**\n     * Render the XY output with groups of pixels averaged together. The group\n     * shape and size matches the full frame's analysis window size.\n     * @type {number}\n     */\n    XY_CELL: 1,\n\n    /**\n     * Render three color components matching the detection algorith's values\n     * that multiple the horizontal difference, or x value, and the vertical\n     * difference, or y value together. The red component is the x value\n     * squared. The green component is the y value squared. The blue component\n     * is the x value times the y value. The detection code refers to these\n     * values as A2, B1, and A1B2.\n     * @type {number}\n     */\n    AB: 2,\n\n    /**\n     * Render the AB output of groups of pixels summarized by their combined\n     * square root. The group shape and size matches the full frame's analysis\n     * window size.\n     * @type {number}\n     */\n    AB_CELL: 3,\n\n    /**\n     * Render a single color component matching the temporal difference or the\n     * difference in color for the same pixel coordinate in the current frame\n     * and the last frame. The difference is rendered in the blue color\n     * component since x and y axis differences tend to use red and green.\n     * @type {number}\n     */\n    T: 4,\n\n    /**\n     * Render the T output of groups of pixels averaged. The group shape and\n     * size matches the full frame's analysis window.\n     * @type {number}\n     */\n    T_CELL: 5,\n\n    /**\n     * Render the XY and T outputs together. The x and y axis values use the\n     * red and green color components as they do in the XY output. The t values\n     * use the blue color component as the T output does.\n     * @type {number}\n     */\n    XYT: 6,\n\n    /**\n     * Render the XYT output of groups of pixels averaged. The group shape and\n     * size matches the full frame's analysis window.\n     * @type {number}\n     */\n    XYT_CELL: 7,\n\n    /**\n     * Render the horizontal pixel difference times the temporal difference as\n     * red and the vertical and temporal difference as green. Multiplcation of\n     * these values ends up with sharp differences in the output showing edge\n     * details where motion is happening.\n     * @type {number}\n     */\n    C: 8,\n\n    /**\n     * Render the C output of groups of pixels averaged. The group shape and\n     * size matches the full frame's analysis window.\n     * @type {number}\n     */\n    C_CELL: 9,\n\n    /**\n     * Render a per pixel version of UV_CELL. UV_CELL is a close to final step\n     * of the motion code that builds a motion amount and direction from those\n     * values. UV_CELL renders grouped summarized values, UV does the per pixel\n     * version but its can only represent one motion vector code path out of\n     * two choices. Determining the motion vector compares some of the built\n     * values but building the values with one pixel ensures this first\n     * comparison says the values are equal. Even though only one code path is\n     * used to build the values, its output is close to approximating the\n     * better solution building vectors from groups of pixels to help\n     * illustrate when the code determines the motion amount and direction to\n     * be.\n     * @type {number}\n     */\n    UV: 10,\n\n    /**\n     * Render cells of mulitple pixels at a step in the motion code that has\n     * the same cell values and turns them into motion vectors showing the\n     * amount of motion in the x axis and y axis separately. Those values are a\n     * step away from becoming a motion amount and direction through standard\n     * vector to magnitude and angle values.\n     * @type {number}\n     */\n    UV_CELL: 11\n};\n\n/**\n * Temporary storage structure for returning values in\n * VideoMotionView._components.\n * @type {object}\n */\nconst _videoMotionViewComponentsTmp = {\n    A2: 0,\n    A1B2: 0,\n    B1: 0,\n    C2: 0,\n    C1: 0\n};\n\n/**\n * Manage a debug canvas with VideoMotion input frames running parts of what\n * VideoMotion does to visualize what it does.\n * @param {VideoMotion} motion - VideoMotion with inputs to visualize\n * @param {OUTPUT} output - visualization output mode\n * @constructor\n */\nclass VideoMotionView {\n    constructor (motion, output = OUTPUT.XYT) {\n        /**\n         * VideoMotion instance to visualize.\n         * @type {VideoMotion}\n         */\n        this.motion = motion;\n\n        /**\n         * Debug canvas to render to.\n         * @type {HTMLCanvasElement}\n         */\n        const canvas = this.canvas = document.createElement('canvas');\n        canvas.width = WIDTH;\n        canvas.height = HEIGHT;\n\n        /**\n         * 2D context to draw to debug canvas.\n         * @type {CanvasRendering2DContext}\n         */\n        this.context = canvas.getContext('2d');\n\n        /**\n         * Visualization output mode.\n         * @type {OUTPUT}\n         */\n        this.output = output;\n\n        /**\n         * Pixel buffer to store output values into before they replace the last frames info in the debug canvas.\n         * @type {Uint32Array}\n         */\n        this.buffer = new Uint32Array(WIDTH * HEIGHT);\n    }\n\n    /**\n     * Modes of debug output that can be rendered.\n     * @type {object}\n     */\n    static get OUTPUT () {\n        return OUTPUT;\n    }\n\n    /**\n     * Iterate each pixel address location and call a function with that address.\n     * @param {number} xStart - start location on the x axis of the output pixel buffer\n     * @param {number} yStart - start location on the y axis of the output pixel buffer\n     * @param {nubmer} xStop - location to stop at on the x axis\n     * @param {number} yStop - location to stop at on the y axis\n     * @param {function} fn - handle to call with each iterated address\n     */\n    _eachAddress (xStart, yStart, xStop, yStop, fn) {\n        for (let i = yStart; i < yStop; i++) {\n            for (let j = xStart; j < xStop; j++) {\n                const address = (i * WIDTH) + j;\n                fn(address, j, i);\n            }\n        }\n    }\n\n    /**\n     * Iterate over cells of pixels and call a function with a function to\n     * iterate over pixel addresses.\n     * @param {number} xStart - start location on the x axis\n     * @param {number} yStart - start lcoation on the y axis\n     * @param {number} xStop - location to stop at on the x axis\n     * @param {number} yStop - location to stop at on the y axis\n     * @param {number} xStep - width of the cells\n     * @param {number} yStep - height of the cells\n     * @param {function} fn - function to call with a bound handle to _eachAddress\n     */\n    _eachCell (xStart, yStart, xStop, yStop, xStep, yStep, fn) {\n        const xStep2 = (xStep / 2) | 0;\n        const yStep2 = (yStep / 2) | 0;\n        for (let i = yStart; i < yStop; i += yStep) {\n            for (let j = xStart; j < xStop; j += xStep) {\n                fn(\n                    _fn => this._eachAddress(j - xStep2 - 1, i - yStep2 - 1, j + xStep2, i + yStep2, _fn),\n                    j - xStep2 - 1,\n                    i - yStep2 - 1,\n                    j + xStep2,\n                    i + yStep2\n                );\n            }\n        }\n    }\n\n    /**\n     * Build horizontal, vertical, and temporal difference of a pixel address.\n     * @param {number} address - address to build values for\n     * @returns {object} a object with a gradX, grady, and gradT value\n     */\n    _grads (address) {\n        const {curr, prev} = this.motion;\n        const gradX = (curr[address - 1] & 0xff) - (curr[address + 1] & 0xff);\n        const gradY = (curr[address - WIDTH] & 0xff) - (curr[address + WIDTH] & 0xff);\n        const gradT = (prev[address] & 0xff) - (curr[address] & 0xff);\n        return {gradX, gradY, gradT};\n    }\n\n    /**\n     * Build component values used in determining a motion vector for a pixel\n     * address.\n     * @param {function} eachAddress - a bound handle to _eachAddress to build\n     *   component values for\n     * @returns {object} a object with a A2, A1B2, B1, C2, C1 value\n     */\n    _components (eachAddress) {\n        let A2 = 0;\n        let A1B2 = 0;\n        let B1 = 0;\n        let C2 = 0;\n        let C1 = 0;\n\n        eachAddress(address => {\n            const {gradX, gradY, gradT} = this._grads(address);\n            A2 += gradX * gradX;\n            A1B2 += gradX * gradY;\n            B1 += gradY * gradY;\n            C2 += gradX * gradT;\n            C1 += gradY * gradT;\n        });\n\n        _videoMotionViewComponentsTmp.A2 = A2;\n        _videoMotionViewComponentsTmp.A1B2 = A1B2;\n        _videoMotionViewComponentsTmp.B1 = B1;\n        _videoMotionViewComponentsTmp.C2 = C2;\n        _videoMotionViewComponentsTmp.C1 = C1;\n        return _videoMotionViewComponentsTmp;\n    }\n\n    /**\n     * Visualize the motion code output mode selected for this view to the\n     * debug canvas.\n     */\n    draw () {\n        if (!(this.motion.prev && this.motion.curr)) {\n            return;\n        }\n\n        const {buffer} = this;\n\n        if (this.output === OUTPUT.INPUT) {\n            const {curr} = this.motion;\n            this._eachAddress(1, 1, WIDTH - 1, HEIGHT - 1, address => {\n                buffer[address] = curr[address];\n            });\n        }\n        if (this.output === OUTPUT.XYT) {\n            this._eachAddress(1, 1, WIDTH - 1, HEIGHT - 1, address => {\n                const {gradX, gradY, gradT} = this._grads(address);\n                const over1 = gradT / 0xcf;\n                buffer[address] =\n                    (0xff << 24) +\n                    (Math.floor((((gradY * over1) & 0xff) + 0xff) / 2) << 8) +\n                    Math.floor((((gradX * over1) & 0xff) + 0xff) / 2);\n            });\n        }\n        if (this.output === OUTPUT.XYT_CELL) {\n            const winStep = (WINSIZE * 2) + 1;\n            const wmax = WIDTH - WINSIZE - 1;\n            const hmax = HEIGHT - WINSIZE - 1;\n\n            this._eachCell(WINSIZE + 1, WINSIZE + 1, wmax, hmax, winStep, winStep, eachAddress => {\n                let C1 = 0;\n                let C2 = 0;\n                let n = 0;\n\n                eachAddress(address => {\n                    const {gradX, gradY, gradT} = this._grads(address);\n                    C2 += (Math.max(Math.min(gradX / 0x0f, 1), -1)) * (gradT / 0xff);\n                    C1 += (Math.max(Math.min(gradY / 0x0f, 1), -1)) * (gradT / 0xff);\n                    n += 1;\n                });\n\n                C1 /= n;\n                C2 /= n;\n                C1 = Math.log(C1 + (1 * Math.sign(C1))) / Math.log(2);\n                C2 = Math.log(C2 + (1 * Math.sign(C2))) / Math.log(2);\n\n                eachAddress(address => {\n                    buffer[address] = (0xff << 24) +\n                        (((((C1 * 0x7f) | 0) + 0x80) << 8) & 0xff00) +\n                        (((((C2 * 0x7f) | 0) + 0x80) << 0) & 0xff);\n                });\n            });\n        }\n        if (this.output === OUTPUT.XY) {\n            this._eachAddress(1, 1, WIDTH - 1, HEIGHT - 1, address => {\n                const {gradX, gradY} = this._grads(address);\n                buffer[address] = (0xff << 24) + (((gradY + 0xff) / 2) << 8) + ((gradX + 0xff) / 2);\n            });\n        }\n        if (this.output === OUTPUT.XY_CELL) {\n            const winStep = (WINSIZE * 2) + 1;\n            const wmax = WIDTH - WINSIZE - 1;\n            const hmax = HEIGHT - WINSIZE - 1;\n\n            this._eachCell(WINSIZE + 1, WINSIZE + 1, wmax, hmax, winStep, winStep, eachAddress => {\n                let C1 = 0;\n                let C2 = 0;\n                let n = 0;\n\n                eachAddress(address => {\n                    const {gradX, gradY} = this._grads(address);\n                    C2 += Math.max(Math.min(gradX / 0x1f, 1), -1);\n                    C1 += Math.max(Math.min(gradY / 0x1f, 1), -1);\n                    n += 1;\n                });\n\n                C1 /= n;\n                C2 /= n;\n                C1 = Math.log(C1 + (1 * Math.sign(C1))) / Math.log(2);\n                C2 = Math.log(C2 + (1 * Math.sign(C2))) / Math.log(2);\n\n                eachAddress(address => {\n                    buffer[address] = (0xff << 24) +\n                        (((((C1 * 0x7f) | 0) + 0x80) << 8) & 0xff00) +\n                        (((((C2 * 0x7f) | 0) + 0x80) << 0) & 0xff);\n                });\n            });\n        } else if (this.output === OUTPUT.T) {\n            this._eachAddress(1, 1, WIDTH - 1, HEIGHT - 1, address => {\n                const {gradT} = this._grads(address);\n                buffer[address] = (0xff << 24) + ((gradT + 0xff) / 2 << 16);\n            });\n        }\n        if (this.output === OUTPUT.T_CELL) {\n            const winStep = (WINSIZE * 2) + 1;\n            const wmax = WIDTH - WINSIZE - 1;\n            const hmax = HEIGHT - WINSIZE - 1;\n\n            this._eachCell(WINSIZE + 1, WINSIZE + 1, wmax, hmax, winStep, winStep, eachAddress => {\n                let T = 0;\n                let n = 0;\n\n                eachAddress(address => {\n                    const {gradT} = this._grads(address);\n                    T += gradT / 0xff;\n                    n += 1;\n                });\n\n                T /= n;\n\n                eachAddress(address => {\n                    buffer[address] = (0xff << 24) +\n                        (((((T * 0x7f) | 0) + 0x80) << 16) & 0xff0000);\n                });\n            });\n        } else if (this.output === OUTPUT.C) {\n            this._eachAddress(1, 1, WIDTH - 1, HEIGHT - 1, address => {\n                const {gradX, gradY, gradT} = this._grads(address);\n                buffer[address] =\n                    (0xff << 24) +\n                    (((Math.sqrt(gradY * gradT) * 0x0f) & 0xff) << 8) +\n                    ((Math.sqrt(gradX * gradT) * 0x0f) & 0xff);\n            });\n        }\n        if (this.output === OUTPUT.C_CELL) {\n            const winStep = (WINSIZE * 2) + 1;\n            const wmax = WIDTH - WINSIZE - 1;\n            const hmax = HEIGHT - WINSIZE - 1;\n\n            this._eachCell(WINSIZE + 1, WINSIZE + 1, wmax, hmax, winStep, winStep, eachAddress => {\n                let {C2, C1} = this._components(eachAddress);\n\n                C2 = Math.sqrt(C2);\n                C1 = Math.sqrt(C1);\n\n                eachAddress(address => {\n                    buffer[address] =\n                        (0xff << 24) +\n                        ((C1 & 0xff) << 8) +\n                        ((C2 & 0xff) << 0);\n                });\n            });\n        } else if (this.output === OUTPUT.AB) {\n            this._eachAddress(1, 1, WIDTH - 1, HEIGHT - 1, address => {\n                const {gradX, gradY} = this._grads(address);\n                buffer[address] =\n                    (0xff << 24) +\n                    (((gradX * gradY) & 0xff) << 16) +\n                    (((gradY * gradY) & 0xff) << 8) +\n                    ((gradX * gradX) & 0xff);\n            });\n        }\n        if (this.output === OUTPUT.AB_CELL) {\n            const winStep = (WINSIZE * 2) + 1;\n            const wmax = WIDTH - WINSIZE - 1;\n            const hmax = HEIGHT - WINSIZE - 1;\n\n            this._eachCell(WINSIZE + 1, WINSIZE + 1, wmax, hmax, winStep, winStep, eachAddress => {\n                let {A2, A1B2, B1} = this._components(eachAddress);\n\n                A2 = Math.sqrt(A2);\n                A1B2 = Math.sqrt(A1B2);\n                B1 = Math.sqrt(B1);\n\n                eachAddress(address => {\n                    buffer[address] =\n                        (0xff << 24) +\n                        ((A1B2 & 0xff) << 16) +\n                        ((B1 & 0xff) << 8) +\n                        (A2 & 0xff);\n                });\n            });\n        } else if (this.output === OUTPUT.UV) {\n            const winStep = (WINSIZE * 2) + 1;\n\n            this._eachAddress(1, 1, WIDTH - 1, HEIGHT - 1, address => {\n                const {A2, A1B2, B1, C2, C1} = this._components(fn => fn(address));\n                const {u, v} = motionVector(A2, A1B2, B1, C2, C1);\n\n                const inRange = (-winStep < u && u < winStep && -winStep < v && v < winStep);\n                const hypot = Math.hypot(u, v);\n                const amount = AMOUNT_SCALE * hypot;\n\n                buffer[address] =\n                    (0xff << 24) +\n                    (inRange && amount > THRESHOLD ?\n                        (((((v / winStep) + 1) / 2 * 0xff) << 8) & 0xff00) +\n                        (((((u / winStep) + 1) / 2 * 0xff) << 0) & 0xff) :\n                        0x8080\n                    );\n            });\n        } else if (this.output === OUTPUT.UV_CELL) {\n            const winStep = (WINSIZE * 2) + 1;\n            const wmax = WIDTH - WINSIZE - 1;\n            const hmax = HEIGHT - WINSIZE - 1;\n\n            this._eachCell(WINSIZE + 1, WINSIZE + 1, wmax, hmax, winStep, winStep, eachAddress => {\n                const {A2, A1B2, B1, C2, C1} = this._components(eachAddress);\n                const {u, v} = motionVector(A2, A1B2, B1, C2, C1);\n\n                const inRange = (-winStep < u && u < winStep && -winStep < v && v < winStep);\n                const hypot = Math.hypot(u, v);\n                const amount = AMOUNT_SCALE * hypot;\n\n                eachAddress(address => {\n                    buffer[address] =\n                        (0xff << 24) +\n                        (inRange && amount > THRESHOLD ?\n                            (((((v / winStep) + 1) / 2 * 0xff) << 8) & 0xff00) +\n                            (((((u / winStep) + 1) / 2 * 0xff) << 0) & 0xff) :\n                            0x8080\n                        );\n                });\n            });\n        }\n\n        const data = new ImageData(new Uint8ClampedArray(this.buffer.buffer), WIDTH, HEIGHT);\n        this.context.putImageData(data, 0, 0);\n    }\n}\n\nmodule.exports = VideoMotionView;\n"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AAZA;;;;;;;;;;;;;;;;;;ACAA;;;;;;;;AASA;AAAA;AAAA;AAEA;;;;;;AAIA;AAEA;;;;;AAIA;AAEA;;;;;;;;;AAQA;AAEA;;;;;;;;;;;AAUA;AAEA;;;;;;AAKA;AAEA;;;;;;AAKA;AAEA;;;;;;AAKA;AAEA;;;;;;AAKA;AAEA;;;;;;;AAMA;;;AACA;AAAA;AACA;AAAA;;;;AAIA;AAEA;;;;;AAIA;AAEA;;;;;AAIA;AAEA;;;;;AAIA;AAEA;;;;;;;AAMA;AAEA;;;;;AAIA;AAEA;;;;;;AAKA;AAEA;;;;;;AAKA;AAEA;;;;;;AAKA;AACA;AAEA;;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;AAKA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AAGA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAXA;AAAA;AAkBA;AACA;AACA;AAGA;AACA;AAAA;AACA;AACA;AAGA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AApCA;AAAA;AAAA;AAsCA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAOA;AACA;AAAA;AACA;AAGA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAtEA;AAAA;AAAA;AACA;AAsEA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;;;;;;;;;;;AChYA;;;;AAIA;AAEA;;;;;;AAKA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;AAWA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;;;AAMA;AACA;AACA;AAEA;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;;;;;;;;;;;;;;;;;ACvEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAIA;AACA;;;;AAIA;AACA;AACA;;;;;;;;;;;;AAYA;AACA;AACA;;;;;AAKA;AACA;AACA;;;;;;;;;AASA;AACA;AACA;;;;;;AAMA;AACA;AACA;;;;;;;AAOA;AACA;AACA;;;;;AAKA;AACA;AACA;;;;;;AAMA;AACA;AACA;;;;;AAKA;AACA;AACA;;;;;;;AAOA;AACA;AACA;;;;;AAKA;AACA;AACA;;;;;;;;;;;;;;AAcA;AACA;AACA;;;;;;;;AAQA;AAtHA;AAyHA;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AALA;AAQA;;;;;;;;AAOA;;;AACA;AAAA;AACA;AADA;AACA;AAAA;;;;AAIA;AAEA;;;;;AAIA;AACA;AACA;AAEA;;;;;AAIA;AAEA;;;;;AAIA;AAEA;;;;;AAIA;AACA;AAEA;;;;;;;;;AAQA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;AAWA;AAAA;AACA;AAAA;AACA;AACA;AAHA;AAAA;AAKA;AACA;AAAA;AANA;AACA;AAGA;AAAA;AAQA;AAZA;AACA;AAEA;AAAA;AAUA;AACA;AAEA;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;;;;;;;;;;AAOA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAIA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAJA;AACA;AAMA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAIA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAIA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAKA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AACA;AAGA;AACA;AACA;AAEA;AAOA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AACA;AAGA;AACA;AACA;AAEA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAzTA;AACA;AACA;;;;;;AA0TA;;;;A","sourceRoot":""}